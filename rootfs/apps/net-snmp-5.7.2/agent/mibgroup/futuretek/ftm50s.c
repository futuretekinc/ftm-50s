/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ftm50s.h"
#include "libconfig.h"
#include "ftnm_client.h"
#define	TABLE_SIZE	10

/* 
 * ftm50s_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ftm50s_variables_oid[] = { 1,3,6,1,4,1,42251,2 };

/* 
 * variable4 ftm50s_variables:
 *   this variable defines function callbacks and type return information 
 *   for the ftm50s mib section 
 */

struct variable5 ftm50s_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define PRODID		1
{PRODID,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 2,  { 1,1 }},
#define PRODMODEL		2
{PRODMODEL,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 2,  { 1,2 }},
#define PRODVENDOR		3
{PRODVENDOR,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 2,  { 1,3 }},
#define PRODHWVER		4
{PRODHWVER,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 2,  { 1,4 }},
#define PRODSWVER		5
{PRODSWVER,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 2,  { 1,5 }},
#define PRODDESCRIPTION		6
{PRODDESCRIPTION,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_ftm50s, 2,  { 1,6 }},
#define NETCOUNT		7
{NETCOUNT,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 2,  { 2,1 }},
#define NETGATEWAYIP		8
{NETGATEWAYIP,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 2,  { 2,3 }},
#define OBJECTCOUNT		9
{OBJECTCOUNT,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 3,  { 3,1,1 }},
#define TEMPCOUNT		10
{TEMPCOUNT,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 3,  { 3,256,1 }},
#define HUMICOUNT		11
{HUMICOUNT,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 3,  { 3,512,1 }},
#define DICOUNT		12
{DICOUNT,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 3,  { 3,1281,1 }},
#define DOCOUNT		13
{DOCOUNT,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 3,  { 3,1537,1 }},
#define GASCOUNT		14
{GASCOUNT,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 3,  { 3,1792,1 }},
#define POWERCOUNT		15
{POWERCOUNT,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 3,  { 3,2048,1 }},
#define AICOUNT		16
{AICOUNT,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 3,  { 3,2560,1 }},
#define COUNTCOUNT		17
{COUNTCOUNT,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_ftm50s, 3,  { 3,2816,1 }},


#define NETID		1
{NETID,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_netTable, 4,  { 2,2 , 1, 1 }},
#define NETTYPE		2
{NETTYPE,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_netTable, 4,  { 2,2 , 1, 2 }},
#define NETMAC		3
{NETMAC,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_netTable, 4,  { 2,2 , 1, 3 }},
#define NETIP		4
{NETIP,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_netTable, 4,  { 2,2 , 1, 4 }},
#define NETMASK		5
{NETMASK,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_netTable, 4,  { 2,2 , 1, 5 }},

#define OBJECTGROUPID		1
{OBJECTGROUPID,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1,2 , 1, 1 }},
#define OBJECTGROUPTYPE		2
{OBJECTGROUPTYPE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1,2 , 1, 2 }},
#define OBJECTGROUPCOUNT		3
{OBJECTGROUPCOUNT,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1,2 , 1, 3 }},
#define OBJECTGROUPOID		4
{OBJECTGROUPOID,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_pointTable, 5,  { 3,1,2 , 1, 4 }},

#define TEMPID		1
{TEMPID,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,256,2 , 1, 1 }},
#define TEMPTYPE		2
{TEMPTYPE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,256,2 , 1, 2 }},
#define TEMPNAME		3
{TEMPNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,256,2 , 1, 3 }},
#define TEMPSN		4
{TEMPSN,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,256,2 , 1, 4 }},
#define TEMPSTATE		5
{TEMPSTATE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,256,2 , 1, 5 }},
#define TEMPVALUE		6
{TEMPVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,256,2 , 1, 6 }},
#define TEMPLASTVALUE		7
{TEMPLASTVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,256,2 , 1, 7 }},
#define TEMPLASTTIME		8
{TEMPLASTTIME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,256,2 , 1, 8 }},
#define TEMPUPDATEINTERVAL		9
{TEMPUPDATEINTERVAL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,256,2 , 1, 9 }},

#define HUMIID		1
{HUMIID,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,512,2 , 1, 1 }},
#define HUMITYPE		2
{HUMITYPE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,512,2 , 1, 2 }},
#define HUMINAME		3
{HUMINAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,512,2 , 1, 3 }},
#define HUMISN		4
{HUMISN,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,512,2 , 1, 4 }},
#define HUMISTATE		5
{HUMISTATE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,512,2 , 1, 5 }},
#define HUMIVALUE		6
{HUMIVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,512,2 , 1, 6 }},
#define HUMILASTVALUE		7
{HUMILASTVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,512,2 , 1, 7 }},
#define HUMILASTTIME		8
{HUMILASTTIME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,512,2 , 1, 8 }},
#define HUMIUPDATEINTERVAL		9
{HUMIUPDATEINTERVAL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,512,2 , 1, 9 }},

#define DIID		1
{DIID,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1281,2 , 1, 1 }},
#define DITYPE		2
{DITYPE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1281,2 , 1, 2 }},
#define DINAME		3
{DINAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,1281,2 , 1, 3 }},
#define DISN		4
{DISN,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1281,2 , 1, 4 }},
#define DISTATE		5
{DISTATE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,1281,2 , 1, 5 }},
#define DIVALUE		6
{DIVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1281,2 , 1, 6 }},
#define DILASTVALUE		7
{DILASTVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1281,2 , 1, 7 }},
#define DILASTTIME		8
{DILASTTIME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1281,2 , 1, 8 }},
#define DIUPDATEINTERVAL		9
{DIUPDATEINTERVAL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,1281,2 , 1, 9 }},

#define DOID		1
{DOID,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1537,2 , 1, 1 }},
#define DOTYPE		2
{DOTYPE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1537,2 , 1, 2 }},
#define DONAME		3
{DONAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,1537,2 , 1, 3 }},
#define DOSN		4
{DOSN,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1537,2 , 1, 4 }},
#define DOSTATE		5
{DOSTATE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,1537,2 , 1, 5 }},
#define DOVALUE		6
{DOVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1537,2 , 1, 6 }},
#define DOLASTVALUE		7
{DOLASTVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1537,2 , 1, 7 }},
#define DOLASTTIME		8
{DOLASTTIME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1537,2 , 1, 8 }},
#define DOUPDATEINTERVAL		9
{DOUPDATEINTERVAL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,1537,2 , 1, 9 }},

#define RLID		1
{RLID,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1538,2 , 1, 1 }},
#define RLTYPE		2
{RLTYPE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1538,2 , 1, 2 }},
#define RLNAME		3
{RLNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,1538,2 , 1, 3 }},
#define RLSN		4
{RLSN,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1538,2 , 1, 4 }},
#define RLSTATE		5
{RLSTATE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,1538,2 , 1, 5 }},
#define RLVALUE		6
{RLVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1538,2 , 1, 6 }},
#define RLLASTVALUE		7
{RLLASTVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1538,2 , 1, 7 }},
#define RLLASTTIME		8
{RLLASTTIME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1538,2 , 1, 8 }},
#define RLUPDATEINTERVAL		9
{RLUPDATEINTERVAL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,1538,2 , 1, 9 }},

#define GASID		1
{GASID,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1792,2 , 1, 1 }},
#define GASTYPE		2
{GASTYPE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1792,2 , 1, 2 }},
#define GASNAME		3
{GASNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,1792,2 , 1, 3 }},
#define GASSN		4
{GASSN,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1792,2 , 1, 4 }},
#define GASSTATE		5
{GASSTATE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,1792,2 , 1, 5 }},
#define GASVALUE		6
{GASVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1792,2 , 1, 6 }},
#define GASLASTVALUE		7
{GASLASTVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1792,2 , 1, 7 }},
#define GASLASTTIME		8
{GASLASTTIME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,1792,2 , 1, 8 }},
#define GASUPDATEINTERVAL		9
{GASUPDATEINTERVAL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,1792,2 , 1, 9 }},

#define POWERID		1
{POWERID,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,2048,2 , 1, 1 }},
#define POWERTYPE		2
{POWERTYPE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,2048,2 , 1, 2 }},
#define POWERNAME		3
{POWERNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,2048,2 , 1, 3 }},
#define POWERSN		4
{POWERSN,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,2048,2 , 1, 4 }},
#define POWERSTATE		5
{POWERSTATE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,2048,2 , 1, 5 }},
#define POWERVALUE		6
{POWERVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,2048,2 , 1, 6 }},
#define POWERLASTVALUE		7
{POWERLASTVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,2048,2 , 1, 7 }},
#define POWERLASTTIME		8
{POWERLASTTIME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,2048,2 , 1, 8 }},
#define POWERUPDATEINTERVAL		9
{POWERUPDATEINTERVAL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,2048,2 , 1, 9 }},

#define COUNTID		1
{COUNTID,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,2816,2 , 1, 1 }},
#define COUNTTYPE		2
{COUNTTYPE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,2816,2 , 1, 2 }},
#define COUNTNAME		3
{COUNTNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,2816,2 , 1, 3 }},
#define COUNTSN		4
{COUNTSN,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,2816,2 , 1, 4 }},
#define COUNTSTATE		5
{COUNTSTATE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,2816,2 , 1, 5 }},
#define COUNTVALUE		6
{COUNTVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,2816,2 , 1, 6 }},
#define COUNTLASTVALUE		7
{COUNTLASTVALUE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,2816,2 , 1, 7 }},
#define COUNTLASTTIME		8
{COUNTLASTTIME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_sensorTable, 5,  { 3,2816,2 , 1, 8 }},
#define COUNTUPDATEINTERVAL		9
{COUNTUPDATEINTERVAL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_sensorTable, 5,  { 3,2816,2 , 1, 9 }},


};
/*    (L = length of the oidsuffix) */

FTNMC_SESSION	xSession;

/** Initializes the ftm50s module */
void
init_ftm50s(void)
{
	static config_t	cfg;
	netsnmp_table_row *row;
	int		value = 0;
	int		value_len = 4;
	in_addr_t	xServerIP = inet_addr("127.0.0.1");

    DEBUGMSGTL(("ftm50s", "Initializing: \n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ftm50s", ftm50s_variables, variable5,
               ftm50s_variables_oid);

    /* place any other initialization junk you need here */
	FTNMC_init(NULL);
	if (FTNMC_connect(&xSession, xServerIP, 8889) == FTM_RET_OK)
	{
		DEBUGMSGTL(("ftm50s", "Client Connected\n"));
	
	}
}

/*
 * var_ftm50s():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
 #define	VALUE	0
 int	VAR;
unsigned char *
var_ftm50s(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) 
	{
    case PRODID:
		{
			strcpy(string, "FTM50S123456");
			*var_len  =strlen(string);

        	return string;
		}

    case PRODMODEL:
		{
			strcpy(string, "FTM50S123456");
			*var_len  =strlen(string);

        	return string;
		}

    case PRODVENDOR:
		{
			strcpy(string, "FutureTek,Inc.");
			*var_len  =strlen(string);

			return	string;
		}

    case PRODHWVER:
		{
			sprintf(string, "1.0.0.0");
			*var_len  =strlen(string);

			return	string;
		}

    case PRODSWVER:
		{
			sprintf(string, "1.0.0.0");
			*var_len  =strlen(string);

			return	string;
		}

    case PRODDESCRIPTION:
		{
        	*write_method = write_prodDescription;
			sprintf(string, "FTM-50S");
			*var_len  =strlen(string);

			return	string;
		}

    case NETCOUNT:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case NETGATEWAYIP:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case OBJECTCOUNT:
        return (u_char*) &VAR;
		{
			FTM_ULONG_PTR	pValue = (FTM_ULONG_PTR)string;

			FTNMC_EP_count(&xSession, 0, pValue);
        	return (u_char*) pValue;
		}

    case TEMPCOUNT:
		{
			FTM_ULONG_PTR	pValue = (FTM_ULONG_PTR)string;

			FTNMC_EP_count(&xSession, FTM_EP_CLASS_TEMPERATURE, pValue);
        	return (u_char*) pValue;
		}

    case HUMICOUNT:
		{
			FTM_ULONG_PTR	pValue = (FTM_ULONG_PTR)string;

			FTNMC_EP_count(&xSession, FTM_EP_CLASS_HUMIDITY, pValue);
        	return (u_char*) pValue;
		}

    case DICOUNT:
		{
			FTM_ULONG_PTR	pValue = (FTM_ULONG_PTR)string;

			FTNMC_EP_count(&xSession, FTM_EP_CLASS_DI, pValue);
        	return (u_char*) pValue;
		}

    case DOCOUNT:
		{
			FTM_ULONG_PTR	pValue = (FTM_ULONG_PTR)string;

			FTNMC_EP_count(&xSession, FTM_EP_CLASS_DO, pValue);
        	return (u_char*) pValue;
		}

    case GASCOUNT:
		{
			FTM_ULONG_PTR	pValue = (FTM_ULONG_PTR)string;

			FTNMC_EP_count(&xSession, FTM_EP_CLASS_GAS, pValue);
        	return (u_char*) pValue;
		}

    case POWERCOUNT:
		{
			FTM_ULONG_PTR	pValue = (FTM_ULONG_PTR)string;

			FTNMC_EP_count(&xSession, FTM_EP_CLASS_POWER, pValue);
        	return (u_char*) pValue;
		}

    case COUNTCOUNT:
		{
			FTM_ULONG_PTR	pValue = (FTM_ULONG_PTR)string;

			FTNMC_EP_count(&xSession, FTM_EP_CLASS_COUNT, pValue);
        	return (u_char*) pValue;
		}

    case AICOUNT:
		{
			FTM_ULONG_PTR	pValue = (FTM_ULONG_PTR)string;

			FTNMC_EP_count(&xSession, FTM_EP_CLASS_AI, pValue);
        	return (u_char*) pValue;
		}

    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_netTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ftm50s above.
 */
unsigned char *
var_netTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case NETID:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case NETTYPE:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case NETMAC:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case NETIP:
        *write_method = write_netIP;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case NETMASK:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_pointTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ftm50s above.
 */
unsigned char *
var_pointTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case OBJECTGROUPID:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case OBJECTGROUPTYPE:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case OBJECTGROUPCOUNT:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case OBJECTGROUPOID:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_sensorTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ftm50s above.
 */
unsigned char *
var_sensorTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
	int		i;
	unsigned long	table_size = 0;
	unsigned long	type, id;
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
	FTM_EPID		xEPID = 0;
	FTM_EP_INFO		xEPInfo;
	FTM_EP_DATA		xEPData;
	FTM_EPID_PTR	pEPIDs;

	if (index < 12)
	{
		return	NULL;	
	}

	type = (unsigned long)name[9] << 16;
	FTNMC_EP_count(&xSession, type, &table_size);

    /* 
   	* This assumes that the table is a 'simple' table.
   	*	See the implementation documentation for the meaning of this.
   	*	You will need to provide the correct value for the TABLE_SIZE parameter
   	*
   	* If this table does not meet the requirements for a simple table,
   	*	you will need to provide the replacement code yourself.
   	*	Mib2c is not smart enough to write this for you.
   	*    Again, see the implementation documentation for what is required.
   	*/
   	if (header_simple_table(vp,name,length,exact,var_len,write_method, table_size) == MATCH_FAILED )
   	{
		printf("match_failed[table_size = %d]\n", __func__, table_size);
		return NULL;
	}

	if (table_size != 0)
	{
		pEPIDs = (FTM_EPID_PTR)calloc(table_size, sizeof(FTM_EPID));
		if (pEPIDs == NULL)
		{
			return	NULL;	
		}

		if (FTNMC_EP_getList(&xSession, type, pEPIDs, table_size, &table_size) != FTM_RET_OK)
		{
			printf("FTNMC_EP_getList(%08lx) Error\n", type);
			free(pEPIDs);	
			return	NULL;
		}

		for(i = 0 ; i < table_size ; i++)
		{
			printf("pEPIDs[i] = %08lx, name[13] = %08lx\n", pEPIDs[i], name[13]);
			if ((pEPIDs[i] & 0xFF)  == name[13])
			{
				xEPID = pEPIDs[i];
				if (FTNMC_EP_get(&xSession, pEPIDs[i], &xEPInfo) != FTM_RET_OK)
				{
					printf("FTNMC_EP_get(%08lx) Error\n", pEPIDs[i]);
					free(pEPIDs);	
					return	NULL;	
				}
				
				break;
			}
		}

		if (!xEPID)
		{
			printf("xEPID is 0 \n");
			free(pEPIDs);
			return	NULL;
		}
	}
	else
	{
		return	NULL;	
	}
	
	printf("vp->magic %08x\n",vp->magic);
    switch(vp->magic) {
    case TEMPID:
		vp->type = ASN_OCTET_STR;
		sprintf(string, "%08x", xEPID);
    	*var_len = strlen(string);
        return string;

    case TEMPTYPE:
		vp->type = ASN_OCTET_STR;
		//if (ft_som_obj_type_get(id, string, sizeof(string)) < 0)
		{
			return	NULL;	
		}
    	*var_len = strlen(string);
        return string;

    case TEMPNAME:
        *write_method = NULL;//write_tempName;

		strcpy(string, xEPInfo.pName);
    	*var_len = strlen(string);
        return string;

    case TEMPSN:
		strcpy(string, xEPInfo.pName);
    	*var_len = strlen(string);
        return string;

    case TEMPSTATE:
		sprintf(string, "Enable");
    	*var_len = strlen(string);
        return string;

    case TEMPVALUE:
		if (FTNMC_EP_DATA_getLast(&xSession, xEPID, &xEPData) != FTM_RET_OK)
		{
			return	NULL;	
		}

		FTM_EP_DATA_snprint(string, sizeof(string), &xEPData);
    	*var_len = strlen(string);
        return string;

    case TEMPLASTVALUE:
		if (FTNMC_EP_DATA_getLast(&xSession, xEPID, &xEPData) != FTM_RET_OK)
		{
			return	NULL;	
		}

		FTM_EP_DATA_snprint(string, sizeof(string), &xEPData);
    	*var_len = strlen(string);
        return string;

    case TEMPLASTTIME:
		{
			int	nLen;

			if (FTNMC_EP_DATA_getLast(&xSession, xEPID, &xEPData) != FTM_RET_OK)
			{
				return	NULL;	
			}

			ctime_r((time_t *)&xEPData.ulTime, string);	
			nLen = strlen(string);
			if (nLen != 0)
			{
				string[nLen-1] = '\0';
				nLen--;
			}

			*var_len = nLen;
			return string;
		}

	case TEMPUPDATEINTERVAL:
	*write_method = NULL;//write_tempUpdateInterval;
		*((FTM_ULONG_PTR)string) = xEPInfo.ulInterval;
		return (u_char*) string;

	default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_prodDescription(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to ftm50s not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to ftm50s: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_netIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to ftm50s not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to ftm50s: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_sensorName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to ftm50s not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to ftm50s: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_sensorState(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to ftm50s not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to ftm50s: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_sensorUpdateInterval(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to ftm50s not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to ftm50s: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

