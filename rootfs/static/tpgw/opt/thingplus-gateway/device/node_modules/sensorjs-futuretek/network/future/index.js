'use strict';

var util = require('util'),
    snmp = require ('net-snmp'),
    snmpParser = require('snmp-native'),
    async = require ('async'),
    dgram = require('dgram'),
    _ = require ('lodash'),
    LRU = require('lru-cache');

var Device = require('../../index').Device,
    Network = require('../../index').Network,
    logger = Network.getLogger(),
    snmpHelper = require('../../snmpHelper'),
    cfg = snmpHelper.config;

//devices cache has active devices: maxage 3min, polling 1min 
var _devices = LRU({
  maxAge: cfg.SCAN_INTERVAL * 3,
  dispose: function (addr, device) {  
    if (device) {
      device.removeAllListeners();
    }
    logger.info('future:cache disposed device', addr);
  },
}),
_initializing,
_initialized;

var init; // function

function Future(options) {
  Network.call(this, 'future', options);
  init(this);
}

util.inherits(Future, Network);

Network.prototype.getDevice = function (addr, options, cb) {
  if (typeof options === 'function') {
    cb = options;
  }
  var device = _devices.peek(addr);
  logger.debug('getDevice', addr, device);
  return cb && cb(undefined, device);
};

function retrieveDeviceInfo(targetIp, driverOrModel, cb) {
  var sensorInfos = [],
      session = snmp.createSession(targetIp, 'public', cfg.SNMP_OPTIONS),
      macAddr;

  async.waterfall([
    function (done) { // get mac id
      snmpHelper.getSNMP(session, cfg.MAC_OID, function (err, result) {
        macAddr = result && result[cfg.MAC_OID] && result[cfg.MAC_OID].toString();
        if (!err && !macAddr) {
          err = new Error('mac id not found');
        } 
        macAddr = macAddr && macAddr.replace(/:/g, '').trim().toLowerCase();
        return done(err);
      });
    },
    function (done) { // get sensors #
      var countOids = _.pluck(cfg.SENSOR_OIDS, 'countOid'),
          ids = [], i;
      snmpHelper.getSNMP(session, countOids, function (err, result) {
        if (err) { return done(err); }
        _.each(result && cfg.SENSOR_OIDS, function (sensor) {
          var count = result[sensor.countOid];
          for(i=0; i < count; i++) {
            ids.push(sensor.IDsOid + '.' + (i+1));
          }
        });
        return done(null, ids);
      });
    },
    function (ids, done) { // get sensor types
      snmpHelper.getSNMP(session, ids, function (err, result) {
        _.each(result, function (serial, oid) {
          var sensor = _.find(cfg.SENSOR_OIDS, {
            IDsOid: oid.substring(0, oid.lastIndexOf('.'))
          });
          if (!sensor) {
            logger.error('future:retrieveDeviceInfo no sensor ', serial, oid);
            return; //continue
          } 
          if (!driverOrModel || (sensor.driver === driverOrModel)) {
            logger.info('retrieveDeviceInfo oid', oid, 'id', result[oid].toString());
            sensorInfos.push({
              id: [macAddr, result[oid].toString()].join('-'),
              oid: oid,
              model: sensor.model,
              device: {
                sensorNetwork: 'future',
                address: macAddr
              }
            });
          }
        });
        logger.debug('found sensors', sensorInfos);
        if (!err && _.isEmpty(sensorInfos)) {
          logger.error('future:retrieveDeviceInfo no sensors', targetIp, macAddr);
          err = new Error('no sensor infos');
        }
        return done(err);
      });
    }
  ], function (err) {
    try {
      session.close();
    } catch(e) {
      logger.error('[network/future] error on closing session', e);
    }

    if (err) {
      return cb && cb(err);
    } else {
      return cb && cb(err, macAddr, sensorInfos);
    }
  });
}

function startScanning(self, cb) {
  var sender = dgram.createSocket('udp4'),
      listener = dgram.createSocket('udp4'),
      hello = new Buffer('Hello?');

  try {
    listener.bind(cfg.SNMP_TRAP_PORT, function() {
      logger.debug('[future:scan]bound SNMP_TRAP_PORT');
    });
    listener.on('message', function(msg, rinfo) {
      var targetIp = rinfo && rinfo.address,
      parsedMsg, startTime, discoveryMsg, alertMsg;

      try {
        parsedMsg = snmpParser.parse(msg);
        logger.debug('Parse: ', parsedMsg);
      } catch (e) {
        logger.error('snmp parse exp', e);
        return;
      }

      _.each(parsedMsg.pdu.varbinds, function (vb) {
        var oid = vb.oid && vb.oid.join('.');
        switch (oid) {         
        case cfg.UPTIME_OID:
          startTime = _.now() - (vb.value * 10);
          logger.debug ('startTime = ', new Date(startTime));
          break;
        case cfg.DISCOVERY_MSG_OID:
          try {
            discoveryMsg = JSON.parse(vb.value); 
            if (discoveryMsg.MAC) {
              discoveryMsg.MAC = discoveryMsg.MAC.replace(/:/g,'').toLowerCase();
            }
            logger.info('discovery msg', discoveryMsg);
            retrieveDeviceInfo(targetIp, undefined, function (err, addr, sensorInfos) {
              var device;
              if (!err && addr) {
                device = _devices.get(addr);
                if (device) {
                  //any change in extraInfo
                  _devices.set(addr, device);
                  logger.debug('future:cache update device', addr);
                  if (!device.extraInfo || 
                    device.extraInfo.deviceId !== discoveryMsg.PID ||
                    device.extraInfo.ipAddr !== targetIp ||
                    Math.abs(device.extraInfo.startTime - startTime) > 3*1000/*3s*/) {
                    logger.error('future:cache extraInfo changed: before', addr, device.extraInfo);
                    device.extraInfo = { ipAddr: targetIp, startTime: startTime,
                        deviceId: discoveryMsg.PID, sensorInfos: sensorInfos};
                    logger.error('future:cache extraInfo changed: after', addr, device.extraInfo);
                  }
                } else {
                  //FIXME: create snmp session here and share all sensors of the device
                  device = new Device(self, addr, sensorInfos);
                  device.extraInfo = { ipAddr: targetIp, startTime: startTime, 
                      deviceId: discoveryMsg.PID, sensorInfos: sensorInfos};
                  _devices.set(addr, device);
                  //request from sensor driver
                  device.on('enableChange', function(/*oid*/) {
                    var setVarbind = {
                      oid: cfg.TRAP_ADD_OID,
                      type: snmp.ObjectType.OctetString,
                      value: snmpHelper.getLocalAddr(targetIp), //FIXME: check null?
                    },
                    session = snmp.createSession(targetIp, 'public', cfg.SNMP_OPTIONS);
                    logger.debug('setVarBind', {
                      oid: cfg.TRAP_ADD_OID,
                      type: snmp.ObjectType.OctetString,
                      value: snmpHelper.getLocalAddr(targetIp), //FIXME: check null?
                    });
                    //FIXME: check existing values before set
                    snmpHelper.setSNMP(session, [setVarbind], function (err, result) {
                      if (err) {
                        logger.error('[network/future] failure to enableChange', err, result);
                      }
                      try {
                        session.close();
                      } catch(e) {
                        logger.error('[network/future] error on closing setSNMP session', e);
                      }
                    });
                  });
                  logger.warn('future:cache set found device', device.address, 
                              device.sensorUrls, device.extraInfo);
                }
              } else {
                logger.error('future:cache get device error', addr, err);
                if (addr) {
                  _devices.del(addr);
                  logger.error('future:cache del device:', addr);
                }
              }
            });
          } catch (e) {
            logger.error('discovery msg: malformat', e, discoveryMsg);
          }
          break;
        case cfg.ALERT_MSG_OID:
          try {
            alertMsg = JSON.parse(vb.value); 
            logger.debug('alert msg', alertMsg, targetIp);
            _.each(_devices.values(), function (device) {
              if (device.extraInfo && device.extraInfo.ipAddr === targetIp) {
                device.emit('change', alertMsg);
                return false;
              }
            });
          } catch (e) {
            logger.error('alert msg: malformat');
          }
          break;
        default:
          logger.debug ('unknown ', oid, '=', vb.value);
        }
      });
    });

    //sender
    sender.bind(function () {
      sender.setBroadcast(true);
    });
    //FIXME: send multiple times considering loss
    _.each(_.pluck(cfg.NET_IF_LIST, 'bcast'), function (addr) { 
      sender.send(hello, 0, hello.length, cfg.SCAN_PORT, addr);
    });
    setInterval(function () {
      _.each(_.pluck(cfg.NET_IF_LIST, 'bcast'), function (addr) {
        sender.send(hello, 0, hello.length, cfg.SCAN_PORT, addr);
      });
    }, cfg.SCAN_INTERVAL);

    return cb && cb();
  } catch (e) {
    logger.error('future:scan err=', e);
    sender.close();
    listener.close();
    return cb && cb(e);
  }
}

Future.prototype.discover = function (driverOrModel, cb) {
  var self = this;

  if (_.isFunction(driverOrModel)) {
    cb = driverOrModel;
    driverOrModel = undefined;
  }

  init(self, function () { // to be sure initialzed 
    if (cb) {
      cb(undefined, _devices.values());
    } else {
      _.each(_devices.values(), function (device) {
        self.emit('discovered', device);
      });
      self.emit('done');
    }
  });
};

init = function init(self, cb) {
  if (_initialized) {
    return cb && cb();
  }
  if (_initializing && cb) {// max 5secs waiting 
    var tries = 5, timer = setInterval(function () {
      tries--;
      if (_initialized) {
        clearInterval(timer);
        return cb();
      } else if (tries < 0) {
        clearInterval(timer);
        return cb(new Error('init lasts too long'));
      }
    }, 1000);
  }

  _initializing = true;

  async.series([
    function (done) { // get broadcast addrs
      snmpHelper.initNetIfList(function (err) {
        if (!err) {
          logger.info('future:bcastAddrs', _.pluck(cfg.NET_IF_LIST, 'bcast'));
        }
        return done(err);
      });
    },
    function (done) {
      startScanning(self, function (err) {
        return done(err);
      });
    },
  ], function (err) {
    if (err) {
      logger.fatal('future:network init failure', err);
      return;
    }
    _initialized = true;
    _initializing = false;
    logger.info('future:network init done');
    return cb && cb();
  });
};

module.exports = new Future();
