'use strict';
var util = require('util'),
    _ = require('lodash'),
    snmp = require ('net-snmp');

var SensorLib = require('../../index'),
    Actuator = SensorLib.Actuator,
    logger = Actuator.getLogger(),
    snmpHelper = require('../../snmpHelper'),
    cfg = snmpHelper.config;

var DEFAULT_BLINK_INTERVAL = 5000; // 5 secs

function chkSession(self, cb) {
  var network = self.info && self.info.device && 
                self.info.device.sensorNetwork &&
                SensorLib.getNetwork(self.info.device.sensorNetwork),
      prevIp = self.ip;

  if (!network || !self.info.device.address) {
    logger.error('futureSensor:chkSession invalid device info', self.info);
    return cb && cb(new Error('invalid device info'));
  }
  network.getDevice(self.info.device.address, function (err, device) {
    var si;

    self.ip = device && device.extraInfo && device.extraInfo.ipAddr;

    if (!self.ip) {
      logger.error('futureSensor:chkSession missing device', self.info);
      return cb && cb(new Error('missing device'));
    }

    si = _.find(device.extraInfo && device.extraInfo.sensorInfos, {id: self.id});
    if (si && si.oid) {
      self.oidIdx = Number(si.oid.substring(si.oid.lastIndexOf('.')+1));
    }
    if (!si || ((self.oidIdx !==0) && !self.oidIdx)) {
      logger.error('futureSensor: cannot find sensorinfo', self.id, self.oid);
    }

    if (self.ip === prevIp && self.session) {//no ip change keep session
      return cb && cb();
    } else { 
      logger.debug('futureSensor:chkSession ip change or no session:', self.id, prevIp, self.ip);
      if (self.session) {
        self.session.close();
        delete self.session;
      }
      self.session = snmp.createSession(self.ip, 'public', cfg.SNMP_OPTIONS);
      logger.warn('futureSensor:chkSession new session:', self.id, self.ip);
      return cb && cb();
    }
  });
}

function FutureActuator(sensorInfo, options) {
  Actuator.call(this, sensorInfo, options);
  if (sensorInfo.model) {
    this.model = sensorInfo.model;
  }
  //future = sensorDriver.getNetwork('future');
  logger.debug('FutureActuator', sensorInfo);
  this.oidIdx = Number(this.id.slice(-2)); // FIXME: last 2 disits from id
  this.dataTypes = _.first(FutureActuator.properties.dataTypes[this.model]);

  this.throttledChkSession = _.throttle(_.partial(chkSession, this), 60*1000, {trailing: false});
  this.throttledChkSession();
}

FutureActuator.properties = {
  supportedNetworks: ['future'],
  dataTypes: ['powerSwitch'],
  discoverable: true,
  maxInstances: 5,
  models: ['futureDo'],
  commands: ['on', 'off', 'blink'],
};

util.inherits(FutureActuator, Actuator);

/* options.duration: infinite if NaN, null, undefined, zero or minus */
FutureActuator.prototype.on = function (options, cb) {
  var self = this,
  duration = options && Number(options.duration, 10);


  this._clearTimer();

  if (!duration || duration <= 0) {
    duration = 0; 
  }

  this.__set(1, function (err) {
    if (duration) {
      self.offTimer = setTimeout(function () {
        self.offTimer = null;
        self.off();
      }, duration);
    }
    return _.isFunction(cb) && cb(err, self.id + ' is on');
  });
};

FutureActuator.prototype.off = function (options, cb) {
  var self = this;

  this._clearTimer();
  this.__set(0, function (err) {
    return _.isFunction(cb) && cb(err, self.id + ' is off');
  });
};

FutureActuator.prototype.__set = function (value, cb) {
  var self = this,
  sensor = _.find(cfg.SENSOR_OIDS, {model: self.model}),
  setOid =  sensor.valuesOid && sensor.valuesOid + '.' + this.oidIdx,
  setVarbind = {
    oid: setOid,
    type: snmp.ObjectType.OctetString,
    value: value.toString(),
  };

  if (!self.session) {
    self.throttledChkSession();
    logger.error('[futureActuator:_set]snmp session is not ready', self.id, self.model, self.ip);
    return cb && cb(new Error('snmp session is not ready'));
  }

  snmpHelper.setSNMP(self.session, [setVarbind], function (err, result) {
    if (!err) {
      logger.info('[futureActuator:_set] set val=', result && result[setOid] && result[setOid].toString());
      return cb && cb();
    } else {
      self.throttledChkSession();
      logger.error('[futureActuator:_set]snmp set failure', err, result);
      return cb && cb(new Error('snmp set failure'));
    }
  });
};

/* Blink 
 * interval: blink interval(default: 5 sec)
 * options.duration: infinite if NaN, null, undefined, zero or minus
 */
FutureActuator.prototype.blink = function (options, cb) {
  var self = this,
  interval = options && Number(options.interval, 10),
  duration = options && Number(options.duration, 10),
  value = 1;

  this._clearTimer();

  if (!interval || interval <= 0) {
    interval = DEFAULT_BLINK_INTERVAL; 
  }

  if (!duration || duration <= 0) {
    duration = 0; 
  }

  self.blinkTimer = setInterval(function () {
    self.__set(value, function (err) {
      value = value === 1 ? 0 : 1; // toggle value
      return _.isFunction(cb) && 
          cb(err, self.id + ' is ' + (value === 1 ? 'on' : 'off'));
    });
  }, interval || DEFAULT_BLINK_INTERVAL);

  if (duration) {
    self.offTimer = setTimeout(function () {
      clearInterval(self.blinkTimer);
      self.blinkTimer = null;
      self.offTimer = null;
      self.off();
    }, duration);
  }

  return _.isFunction(cb) && cb(null, this.id + ' is blinking');
};

FutureActuator.prototype._clearTimer = function () {
  if (this.blinkTimer) {
    clearInterval(this.blinkTimer);
    this.blinkTimer = null;
  }
  if (this.offTimer) {
    clearTimeout(this.offTimer);
    this.offTimer = null;
  }
};

FutureActuator.prototype._clear = function () {
  this._clearTimer();
  if (this.session) {
    this.session.close();
    delete this.session;
  }
  return;
};

module.exports = FutureActuator;
